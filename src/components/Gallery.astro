---
import { Image } from 'astro:assets';
import image1 from '../assets/image-1.jpg';
import image2 from '../assets/image-6.jpg';
import image3 from '../assets/hero.jpg';
import image4 from '../assets/image-4.jpg';
import image5 from '../assets/image-9.jpg';
import image6 from '../assets/image-16.jpg';

const galleryImages = [image1, image2, image3, image4, image5, image6];
---

<section class="w-full bg-black py-20">
    <div class="max-w-[1920px] mx-auto px-4 sm:px-8">
        <h2 class="text-4xl md:text-5xl font-serif text-white text-center mb-16">Gallery</h2>
        
        <div class="gallery-container overflow-hidden relative">
            <div class="gallery-track flex gap-6 cursor-pointer whitespace-nowrap">
                {galleryImages.map((image, index) => (
                    <div class="gallery-item min-w-[260px] md:min-w-[400px] aspect-square rounded-lg overflow-hidden hover:scale-105 transition-transform duration-300 inline-block">
                        <Image 
                            src={image} 
                            alt={`Gallery ${index + 1}`}
                            width={400}
                            height={400}
                            loading="lazy"
                            format="webp"
                            quality={75}
                            class="w-full h-full object-cover"
                            decoding="async"
                        />
                    </div>
                ))}
            </div>
        </div>
    </div>
</section>

<style>
    .gallery-track {
        will-change: transform;
    }

    .gallery-track:hover {
        /* We'll handle this in JS too */
    }
</style>

<script>
    window.addEventListener('load', () => {
        const track = document.querySelector('.gallery-track') as HTMLElement;
        if (!track) return;

        let animationFrameId: number | null = null;
        let isPaused = false;
        let scrollPosition = 0;

        function initializeGallery() {
            // Reset existing state
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            scrollPosition = 0;
            track.style.transform = 'translateX(0)';

            // Remove any previously cloned items
            while (track.children.length > 6) { // 6 is the original number of images
                track.removeChild(track.lastChild!);
            }

            // Get dimensions after any possible layout shifts
            const items = track.children;
            const gap = 24; // 1.5rem = 24px
            const itemWidth = (items[0] as HTMLElement).offsetWidth + gap;
            
            // Clone enough items to fill the screen width plus buffer
            const viewportWidth = window.innerWidth;
            const itemsNeeded = Math.ceil((viewportWidth * 2) / itemWidth);
            
            // Clone items
            for (let i = 0; i < itemsNeeded; i++) {
                const index = i % items.length;
                track.appendChild(items[index].cloneNode(true));
            }

            function animate() {
                if (!isPaused) {
                    // Adjust speed based on screen size
                    const speed = window.innerWidth < 768 ? 1 : 2;
                    scrollPosition -= speed;
                    track.style.transform = `translateX(${scrollPosition}px)`;

                    if (Math.abs(scrollPosition) >= itemWidth) {
                        scrollPosition += itemWidth;
                        track.style.transform = `translateX(${scrollPosition}px)`;
                        
                        const firstItem = track.children[0];
                        track.appendChild(firstItem.cloneNode(true));
                        track.removeChild(firstItem);
                    }
                }
                animationFrameId = requestAnimationFrame(animate);
            }

            // Start animation
            animate();
        }

        // Initialize gallery
        initializeGallery();

        // Handle hover/touch events
        track.addEventListener('mouseenter', () => isPaused = true);
        track.addEventListener('mouseleave', () => isPaused = false);
        track.addEventListener('touchstart', () => isPaused = true);
        track.addEventListener('touchend', () => isPaused = false);

        // Reinitialize on resize with debounce
        let resizeTimeout: number;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(initializeGallery, 250) as unknown as number;
        });

        // Cleanup
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            } else {
                initializeGallery();
            }
        });
    });
</script> 